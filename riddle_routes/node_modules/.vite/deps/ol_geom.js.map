{
  "version": 3,
  "sources": ["../../ol/geom/Circle.js", "../../ol/geom/GeometryCollection.js", "../../ol/geom/flat/interpolate.js", "../../ol/geom/LineString.js", "../../ol/geom/MultiLineString.js", "../../ol/geom/MultiPoint.js", "../../ol/geom/flat/center.js", "../../ol/geom/MultiPolygon.js"],
  "sourcesContent": ["/**\r\n * @module ol/geom/Circle\r\n */\r\nimport SimpleGeometry from './SimpleGeometry.js';\r\nimport {createOrUpdate, forEachCorner, intersects} from '../extent.js';\r\nimport {deflateCoordinate} from './flat/deflate.js';\r\nimport {rotate, translate} from './flat/transform.js';\r\n\r\n/**\r\n * @classdesc\r\n * Circle geometry.\r\n *\r\n * @api\r\n */\r\nclass Circle extends SimpleGeometry {\r\n  /**\r\n   * @param {!import(\"../coordinate.js\").Coordinate} center Center.\r\n   *     For internal use, flat coordinates in combination with `layout` and no\r\n   *     `radius` are also accepted.\r\n   * @param {number} [radius] Radius.\r\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\r\n   */\r\n  constructor(center, radius, layout) {\r\n    super();\r\n    if (layout !== undefined && radius === undefined) {\r\n      this.setFlatCoordinates(layout, center);\r\n    } else {\r\n      radius = radius ? radius : 0;\r\n      this.setCenterAndRadius(center, radius, layout);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Make a complete copy of the geometry.\r\n   * @return {!Circle} Clone.\r\n   * @api\r\n   */\r\n  clone() {\r\n    const circle = new Circle(\r\n      this.flatCoordinates.slice(),\r\n      undefined,\r\n      this.layout\r\n    );\r\n    circle.applyProperties(this);\r\n    return circle;\r\n  }\r\n\r\n  /**\r\n   * @param {number} x X.\r\n   * @param {number} y Y.\r\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\r\n   * @param {number} minSquaredDistance Minimum squared distance.\r\n   * @return {number} Minimum squared distance.\r\n   */\r\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\r\n    const flatCoordinates = this.flatCoordinates;\r\n    const dx = x - flatCoordinates[0];\r\n    const dy = y - flatCoordinates[1];\r\n    const squaredDistance = dx * dx + dy * dy;\r\n    if (squaredDistance < minSquaredDistance) {\r\n      if (squaredDistance === 0) {\r\n        for (let i = 0; i < this.stride; ++i) {\r\n          closestPoint[i] = flatCoordinates[i];\r\n        }\r\n      } else {\r\n        const delta = this.getRadius() / Math.sqrt(squaredDistance);\r\n        closestPoint[0] = flatCoordinates[0] + delta * dx;\r\n        closestPoint[1] = flatCoordinates[1] + delta * dy;\r\n        for (let i = 2; i < this.stride; ++i) {\r\n          closestPoint[i] = flatCoordinates[i];\r\n        }\r\n      }\r\n      closestPoint.length = this.stride;\r\n      return squaredDistance;\r\n    } else {\r\n      return minSquaredDistance;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {number} x X.\r\n   * @param {number} y Y.\r\n   * @return {boolean} Contains (x, y).\r\n   */\r\n  containsXY(x, y) {\r\n    const flatCoordinates = this.flatCoordinates;\r\n    const dx = x - flatCoordinates[0];\r\n    const dy = y - flatCoordinates[1];\r\n    return dx * dx + dy * dy <= this.getRadiusSquared_();\r\n  }\r\n\r\n  /**\r\n   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\r\n   * @return {import(\"../coordinate.js\").Coordinate} Center.\r\n   * @api\r\n   */\r\n  getCenter() {\r\n    return this.flatCoordinates.slice(0, this.stride);\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @protected\r\n   * @return {import(\"../extent.js\").Extent} extent Extent.\r\n   */\r\n  computeExtent(extent) {\r\n    const flatCoordinates = this.flatCoordinates;\r\n    const radius = flatCoordinates[this.stride] - flatCoordinates[0];\r\n    return createOrUpdate(\r\n      flatCoordinates[0] - radius,\r\n      flatCoordinates[1] - radius,\r\n      flatCoordinates[0] + radius,\r\n      flatCoordinates[1] + radius,\r\n      extent\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return the radius of the circle.\r\n   * @return {number} Radius.\r\n   * @api\r\n   */\r\n  getRadius() {\r\n    return Math.sqrt(this.getRadiusSquared_());\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @return {number} Radius squared.\r\n   */\r\n  getRadiusSquared_() {\r\n    const dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];\r\n    const dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];\r\n    return dx * dx + dy * dy;\r\n  }\r\n\r\n  /**\r\n   * Get the type of this geometry.\r\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\r\n   * @api\r\n   */\r\n  getType() {\r\n    return 'Circle';\r\n  }\r\n\r\n  /**\r\n   * Test if the geometry and the passed extent intersect.\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @return {boolean} `true` if the geometry and the extent intersect.\r\n   * @api\r\n   */\r\n  intersectsExtent(extent) {\r\n    const circleExtent = this.getExtent();\r\n    if (intersects(extent, circleExtent)) {\r\n      const center = this.getCenter();\r\n\r\n      if (extent[0] <= center[0] && extent[2] >= center[0]) {\r\n        return true;\r\n      }\r\n      if (extent[1] <= center[1] && extent[3] >= center[1]) {\r\n        return true;\r\n      }\r\n\r\n      return forEachCorner(extent, this.intersectsCoordinate.bind(this));\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\r\n   * @param {import(\"../coordinate.js\").Coordinate} center Center.\r\n   * @api\r\n   */\r\n  setCenter(center) {\r\n    const stride = this.stride;\r\n    const radius = this.flatCoordinates[stride] - this.flatCoordinates[0];\r\n    const flatCoordinates = center.slice();\r\n    flatCoordinates[stride] = flatCoordinates[0] + radius;\r\n    for (let i = 1; i < stride; ++i) {\r\n      flatCoordinates[stride + i] = center[i];\r\n    }\r\n    this.setFlatCoordinates(this.layout, flatCoordinates);\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as\r\n   * number) of the circle.\r\n   * @param {!import(\"../coordinate.js\").Coordinate} center Center.\r\n   * @param {number} radius Radius.\r\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\r\n   * @api\r\n   */\r\n  setCenterAndRadius(center, radius, layout) {\r\n    this.setLayout(layout, center, 0);\r\n    if (!this.flatCoordinates) {\r\n      this.flatCoordinates = [];\r\n    }\r\n    /** @type {Array<number>} */\r\n    const flatCoordinates = this.flatCoordinates;\r\n    let offset = deflateCoordinate(flatCoordinates, 0, center, this.stride);\r\n    flatCoordinates[offset++] = flatCoordinates[0] + radius;\r\n    for (let i = 1, ii = this.stride; i < ii; ++i) {\r\n      flatCoordinates[offset++] = flatCoordinates[i];\r\n    }\r\n    flatCoordinates.length = offset;\r\n    this.changed();\r\n  }\r\n\r\n  getCoordinates() {\r\n    return null;\r\n  }\r\n\r\n  setCoordinates(coordinates, layout) {}\r\n\r\n  /**\r\n   * Set the radius of the circle. The radius is in the units of the projection.\r\n   * @param {number} radius Radius.\r\n   * @api\r\n   */\r\n  setRadius(radius) {\r\n    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Rotate the geometry around a given coordinate. This modifies the geometry\r\n   * coordinates in place.\r\n   * @param {number} angle Rotation angle in counter-clockwise radians.\r\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\r\n   * @api\r\n   */\r\n  rotate(angle, anchor) {\r\n    const center = this.getCenter();\r\n    const stride = this.getStride();\r\n    this.setCenter(\r\n      rotate(center, 0, center.length, stride, angle, anchor, center)\r\n    );\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Translate the geometry.  This modifies the geometry coordinates in place.  If\r\n   * instead you want a new geometry, first `clone()` this geometry.\r\n   * @param {number} deltaX Delta X.\r\n   * @param {number} deltaY Delta Y.\r\n   * @api\r\n   */\r\n  translate(deltaX, deltaY) {\r\n    const center = this.getCenter();\r\n    const stride = this.getStride();\r\n    this.setCenter(\r\n      translate(center, 0, center.length, stride, deltaX, deltaY, center)\r\n    );\r\n    this.changed();\r\n  }\r\n}\r\n\r\n/**\r\n * Transform each coordinate of the circle from one coordinate reference system\r\n * to another. The geometry is modified in place.\r\n * If you do not want the geometry modified in place, first clone() it and\r\n * then use this function on the clone.\r\n *\r\n * Internally a circle is currently represented by two points: the center of\r\n * the circle `[cx, cy]`, and the point to the right of the circle\r\n * `[cx + r, cy]`. This `transform` function just transforms these two points.\r\n * So the resulting geometry is also a circle, and that circle does not\r\n * correspond to the shape that would be obtained by transforming every point\r\n * of the original circle.\r\n *\r\n * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\r\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\r\n * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\r\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\r\n * @return {Circle} This geometry.  Note that original geometry is\r\n *     modified in place.\r\n * @function\r\n * @api\r\n */\r\nCircle.prototype.transform;\r\nexport default Circle;\r\n", "/**\r\n * @module ol/geom/GeometryCollection\r\n */\r\nimport EventType from '../events/EventType.js';\r\nimport Geometry from './Geometry.js';\r\nimport {\r\n  closestSquaredDistanceXY,\r\n  createOrUpdateEmpty,\r\n  extend,\r\n  getCenter,\r\n} from '../extent.js';\r\nimport {listen, unlistenByKey} from '../events.js';\r\n\r\n/**\r\n * @classdesc\r\n * An array of {@link module:ol/geom/Geometry~Geometry} objects.\r\n *\r\n * @api\r\n */\r\nclass GeometryCollection extends Geometry {\r\n  /**\r\n   * @param {Array<Geometry>} [geometries] Geometries.\r\n   */\r\n  constructor(geometries) {\r\n    super();\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<Geometry>}\r\n     */\r\n    this.geometries_ = geometries ? geometries : null;\r\n\r\n    /**\r\n     * @type {Array<import(\"../events.js\").EventsKey>}\r\n     */\r\n    this.changeEventsKeys_ = [];\r\n\r\n    this.listenGeometriesChange_();\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  unlistenGeometriesChange_() {\r\n    this.changeEventsKeys_.forEach(unlistenByKey);\r\n    this.changeEventsKeys_.length = 0;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  listenGeometriesChange_() {\r\n    if (!this.geometries_) {\r\n      return;\r\n    }\r\n    for (let i = 0, ii = this.geometries_.length; i < ii; ++i) {\r\n      this.changeEventsKeys_.push(\r\n        listen(this.geometries_[i], EventType.CHANGE, this.changed, this)\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Make a complete copy of the geometry.\r\n   * @return {!GeometryCollection} Clone.\r\n   * @api\r\n   */\r\n  clone() {\r\n    const geometryCollection = new GeometryCollection(null);\r\n    geometryCollection.setGeometries(this.geometries_);\r\n    geometryCollection.applyProperties(this);\r\n    return geometryCollection;\r\n  }\r\n\r\n  /**\r\n   * @param {number} x X.\r\n   * @param {number} y Y.\r\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\r\n   * @param {number} minSquaredDistance Minimum squared distance.\r\n   * @return {number} Minimum squared distance.\r\n   */\r\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\r\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\r\n      return minSquaredDistance;\r\n    }\r\n    const geometries = this.geometries_;\r\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\r\n      minSquaredDistance = geometries[i].closestPointXY(\r\n        x,\r\n        y,\r\n        closestPoint,\r\n        minSquaredDistance\r\n      );\r\n    }\r\n    return minSquaredDistance;\r\n  }\r\n\r\n  /**\r\n   * @param {number} x X.\r\n   * @param {number} y Y.\r\n   * @return {boolean} Contains (x, y).\r\n   */\r\n  containsXY(x, y) {\r\n    const geometries = this.geometries_;\r\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\r\n      if (geometries[i].containsXY(x, y)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @protected\r\n   * @return {import(\"../extent.js\").Extent} extent Extent.\r\n   */\r\n  computeExtent(extent) {\r\n    createOrUpdateEmpty(extent);\r\n    const geometries = this.geometries_;\r\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\r\n      extend(extent, geometries[i].getExtent());\r\n    }\r\n    return extent;\r\n  }\r\n\r\n  /**\r\n   * Return the geometries that make up this geometry collection.\r\n   * @return {Array<Geometry>} Geometries.\r\n   * @api\r\n   */\r\n  getGeometries() {\r\n    return cloneGeometries(this.geometries_);\r\n  }\r\n\r\n  /**\r\n   * @return {Array<Geometry>} Geometries.\r\n   */\r\n  getGeometriesArray() {\r\n    return this.geometries_;\r\n  }\r\n\r\n  /**\r\n   * @return {Array<Geometry>} Geometries.\r\n   */\r\n  getGeometriesArrayRecursive() {\r\n    /** @type {Array<Geometry>} */\r\n    let geometriesArray = [];\r\n    const geometries = this.geometries_;\r\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\r\n      if (geometries[i].getType() === this.getType()) {\r\n        geometriesArray = geometriesArray.concat(\r\n          /** @type {GeometryCollection} */ (\r\n            geometries[i]\r\n          ).getGeometriesArrayRecursive()\r\n        );\r\n      } else {\r\n        geometriesArray.push(geometries[i]);\r\n      }\r\n    }\r\n    return geometriesArray;\r\n  }\r\n\r\n  /**\r\n   * Create a simplified version of this geometry using the Douglas Peucker algorithm.\r\n   * @param {number} squaredTolerance Squared tolerance.\r\n   * @return {GeometryCollection} Simplified GeometryCollection.\r\n   */\r\n  getSimplifiedGeometry(squaredTolerance) {\r\n    if (this.simplifiedGeometryRevision !== this.getRevision()) {\r\n      this.simplifiedGeometryMaxMinSquaredTolerance = 0;\r\n      this.simplifiedGeometryRevision = this.getRevision();\r\n    }\r\n    if (\r\n      squaredTolerance < 0 ||\r\n      (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&\r\n        squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance)\r\n    ) {\r\n      return this;\r\n    }\r\n\r\n    const simplifiedGeometries = [];\r\n    const geometries = this.geometries_;\r\n    let simplified = false;\r\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\r\n      const geometry = geometries[i];\r\n      const simplifiedGeometry =\r\n        geometry.getSimplifiedGeometry(squaredTolerance);\r\n      simplifiedGeometries.push(simplifiedGeometry);\r\n      if (simplifiedGeometry !== geometry) {\r\n        simplified = true;\r\n      }\r\n    }\r\n    if (simplified) {\r\n      const simplifiedGeometryCollection = new GeometryCollection(null);\r\n      simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);\r\n      return simplifiedGeometryCollection;\r\n    } else {\r\n      this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\r\n      return this;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the type of this geometry.\r\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\r\n   * @api\r\n   */\r\n  getType() {\r\n    return 'GeometryCollection';\r\n  }\r\n\r\n  /**\r\n   * Test if the geometry and the passed extent intersect.\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @return {boolean} `true` if the geometry and the extent intersect.\r\n   * @api\r\n   */\r\n  intersectsExtent(extent) {\r\n    const geometries = this.geometries_;\r\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\r\n      if (geometries[i].intersectsExtent(extent)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * @return {boolean} Is empty.\r\n   */\r\n  isEmpty() {\r\n    return this.geometries_.length === 0;\r\n  }\r\n\r\n  /**\r\n   * Rotate the geometry around a given coordinate. This modifies the geometry\r\n   * coordinates in place.\r\n   * @param {number} angle Rotation angle in radians.\r\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\r\n   * @api\r\n   */\r\n  rotate(angle, anchor) {\r\n    const geometries = this.geometries_;\r\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\r\n      geometries[i].rotate(angle, anchor);\r\n    }\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Scale the geometry (with an optional origin).  This modifies the geometry\r\n   * coordinates in place.\r\n   * @abstract\r\n   * @param {number} sx The scaling factor in the x-direction.\r\n   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).\r\n   * @param {import(\"../coordinate.js\").Coordinate} [anchor] The scale origin (defaults to the center\r\n   *     of the geometry extent).\r\n   * @api\r\n   */\r\n  scale(sx, sy, anchor) {\r\n    if (!anchor) {\r\n      anchor = getCenter(this.getExtent());\r\n    }\r\n    const geometries = this.geometries_;\r\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\r\n      geometries[i].scale(sx, sy, anchor);\r\n    }\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Set the geometries that make up this geometry collection.\r\n   * @param {Array<Geometry>} geometries Geometries.\r\n   * @api\r\n   */\r\n  setGeometries(geometries) {\r\n    this.setGeometriesArray(cloneGeometries(geometries));\r\n  }\r\n\r\n  /**\r\n   * @param {Array<Geometry>} geometries Geometries.\r\n   */\r\n  setGeometriesArray(geometries) {\r\n    this.unlistenGeometriesChange_();\r\n    this.geometries_ = geometries;\r\n    this.listenGeometriesChange_();\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Apply a transform function to the coordinates of the geometry.\r\n   * The geometry is modified in place.\r\n   * If you do not want the geometry modified in place, first `clone()` it and\r\n   * then use this function on the clone.\r\n   * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\r\n   * Called with a flat array of geometry coordinates.\r\n   * @api\r\n   */\r\n  applyTransform(transformFn) {\r\n    const geometries = this.geometries_;\r\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\r\n      geometries[i].applyTransform(transformFn);\r\n    }\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Translate the geometry.  This modifies the geometry coordinates in place.  If\r\n   * instead you want a new geometry, first `clone()` this geometry.\r\n   * @param {number} deltaX Delta X.\r\n   * @param {number} deltaY Delta Y.\r\n   * @api\r\n   */\r\n  translate(deltaX, deltaY) {\r\n    const geometries = this.geometries_;\r\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\r\n      geometries[i].translate(deltaX, deltaY);\r\n    }\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Clean up.\r\n   */\r\n  disposeInternal() {\r\n    this.unlistenGeometriesChange_();\r\n    super.disposeInternal();\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Array<Geometry>} geometries Geometries.\r\n * @return {Array<Geometry>} Cloned geometries.\r\n */\r\nfunction cloneGeometries(geometries) {\r\n  const clonedGeometries = [];\r\n  for (let i = 0, ii = geometries.length; i < ii; ++i) {\r\n    clonedGeometries.push(geometries[i].clone());\r\n  }\r\n  return clonedGeometries;\r\n}\r\n\r\nexport default GeometryCollection;\r\n", "/**\r\n * @module ol/geom/flat/interpolate\r\n */\r\nimport {binarySearch} from '../../array.js';\r\nimport {lerp} from '../../math.js';\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} fraction Fraction.\r\n * @param {Array<number>} [dest] Destination.\r\n * @param {number} [dimension] Destination dimension (default is `2`)\r\n * @return {Array<number>} Destination.\r\n */\r\nexport function interpolatePoint(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  fraction,\r\n  dest,\r\n  dimension\r\n) {\r\n  let o, t;\r\n  const n = (end - offset) / stride;\r\n  if (n === 1) {\r\n    o = offset;\r\n  } else if (n === 2) {\r\n    o = offset;\r\n    t = fraction;\r\n  } else if (n !== 0) {\r\n    let x1 = flatCoordinates[offset];\r\n    let y1 = flatCoordinates[offset + 1];\r\n    let length = 0;\r\n    const cumulativeLengths = [0];\r\n    for (let i = offset + stride; i < end; i += stride) {\r\n      const x2 = flatCoordinates[i];\r\n      const y2 = flatCoordinates[i + 1];\r\n      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\r\n      cumulativeLengths.push(length);\r\n      x1 = x2;\r\n      y1 = y2;\r\n    }\r\n    const target = fraction * length;\r\n    const index = binarySearch(cumulativeLengths, target);\r\n    if (index < 0) {\r\n      t =\r\n        (target - cumulativeLengths[-index - 2]) /\r\n        (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);\r\n      o = offset + (-index - 2) * stride;\r\n    } else {\r\n      o = offset + index * stride;\r\n    }\r\n  }\r\n  dimension = dimension > 1 ? dimension : 2;\r\n  dest = dest ? dest : new Array(dimension);\r\n  for (let i = 0; i < dimension; ++i) {\r\n    dest[i] =\r\n      o === undefined\r\n        ? NaN\r\n        : t === undefined\r\n        ? flatCoordinates[o + i]\r\n        : lerp(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);\r\n  }\r\n  return dest;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} m M.\r\n * @param {boolean} extrapolate Extrapolate.\r\n * @return {import(\"../../coordinate.js\").Coordinate|null} Coordinate.\r\n */\r\nexport function lineStringCoordinateAtM(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  m,\r\n  extrapolate\r\n) {\r\n  if (end == offset) {\r\n    return null;\r\n  }\r\n  let coordinate;\r\n  if (m < flatCoordinates[offset + stride - 1]) {\r\n    if (extrapolate) {\r\n      coordinate = flatCoordinates.slice(offset, offset + stride);\r\n      coordinate[stride - 1] = m;\r\n      return coordinate;\r\n    } else {\r\n      return null;\r\n    }\r\n  } else if (flatCoordinates[end - 1] < m) {\r\n    if (extrapolate) {\r\n      coordinate = flatCoordinates.slice(end - stride, end);\r\n      coordinate[stride - 1] = m;\r\n      return coordinate;\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n  // FIXME use O(1) search\r\n  if (m == flatCoordinates[offset + stride - 1]) {\r\n    return flatCoordinates.slice(offset, offset + stride);\r\n  }\r\n  let lo = offset / stride;\r\n  let hi = end / stride;\r\n  while (lo < hi) {\r\n    const mid = (lo + hi) >> 1;\r\n    if (m < flatCoordinates[(mid + 1) * stride - 1]) {\r\n      hi = mid;\r\n    } else {\r\n      lo = mid + 1;\r\n    }\r\n  }\r\n  const m0 = flatCoordinates[lo * stride - 1];\r\n  if (m == m0) {\r\n    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);\r\n  }\r\n  const m1 = flatCoordinates[(lo + 1) * stride - 1];\r\n  const t = (m - m0) / (m1 - m0);\r\n  coordinate = [];\r\n  for (let i = 0; i < stride - 1; ++i) {\r\n    coordinate.push(\r\n      lerp(\r\n        flatCoordinates[(lo - 1) * stride + i],\r\n        flatCoordinates[lo * stride + i],\r\n        t\r\n      )\r\n    );\r\n  }\r\n  coordinate.push(m);\r\n  return coordinate;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {number} m M.\r\n * @param {boolean} extrapolate Extrapolate.\r\n * @param {boolean} interpolate Interpolate.\r\n * @return {import(\"../../coordinate.js\").Coordinate|null} Coordinate.\r\n */\r\nexport function lineStringsCoordinateAtM(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  m,\r\n  extrapolate,\r\n  interpolate\r\n) {\r\n  if (interpolate) {\r\n    return lineStringCoordinateAtM(\r\n      flatCoordinates,\r\n      offset,\r\n      ends[ends.length - 1],\r\n      stride,\r\n      m,\r\n      extrapolate\r\n    );\r\n  }\r\n  let coordinate;\r\n  if (m < flatCoordinates[stride - 1]) {\r\n    if (extrapolate) {\r\n      coordinate = flatCoordinates.slice(0, stride);\r\n      coordinate[stride - 1] = m;\r\n      return coordinate;\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n  if (flatCoordinates[flatCoordinates.length - 1] < m) {\r\n    if (extrapolate) {\r\n      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);\r\n      coordinate[stride - 1] = m;\r\n      return coordinate;\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n    const end = ends[i];\r\n    if (offset == end) {\r\n      continue;\r\n    }\r\n    if (m < flatCoordinates[offset + stride - 1]) {\r\n      return null;\r\n    } else if (m <= flatCoordinates[end - 1]) {\r\n      return lineStringCoordinateAtM(\r\n        flatCoordinates,\r\n        offset,\r\n        end,\r\n        stride,\r\n        m,\r\n        false\r\n      );\r\n    }\r\n    offset = end;\r\n  }\r\n  return null;\r\n}\r\n", "/**\r\n * @module ol/geom/LineString\r\n */\r\nimport SimpleGeometry from './SimpleGeometry.js';\r\nimport {assignClosestPoint, maxSquaredDelta} from './flat/closest.js';\r\nimport {closestSquaredDistanceXY} from '../extent.js';\r\nimport {deflateCoordinates} from './flat/deflate.js';\r\nimport {douglasPeucker} from './flat/simplify.js';\r\nimport {extend} from '../array.js';\r\nimport {forEach as forEachSegment} from './flat/segments.js';\r\nimport {inflateCoordinates} from './flat/inflate.js';\r\nimport {interpolatePoint, lineStringCoordinateAtM} from './flat/interpolate.js';\r\nimport {intersectsLineString} from './flat/intersectsextent.js';\r\nimport {lineStringLength} from './flat/length.js';\r\n\r\n/**\r\n * @classdesc\r\n * Linestring geometry.\r\n *\r\n * @api\r\n */\r\nclass LineString extends SimpleGeometry {\r\n  /**\r\n   * @param {Array<import(\"../coordinate.js\").Coordinate>|Array<number>} coordinates Coordinates.\r\n   *     For internal use, flat coordinates in combination with `layout` are also accepted.\r\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\r\n   */\r\n  constructor(coordinates, layout) {\r\n    super();\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../coordinate.js\").Coordinate}\r\n     */\r\n    this.flatMidpoint_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.flatMidpointRevision_ = -1;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.maxDelta_ = -1;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.maxDeltaRevision_ = -1;\r\n\r\n    if (layout !== undefined && !Array.isArray(coordinates[0])) {\r\n      this.setFlatCoordinates(\r\n        layout,\r\n        /** @type {Array<number>} */ (coordinates)\r\n      );\r\n    } else {\r\n      this.setCoordinates(\r\n        /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (\r\n          coordinates\r\n        ),\r\n        layout\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Append the passed coordinate to the coordinates of the linestring.\r\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\r\n   * @api\r\n   */\r\n  appendCoordinate(coordinate) {\r\n    if (!this.flatCoordinates) {\r\n      this.flatCoordinates = coordinate.slice();\r\n    } else {\r\n      extend(this.flatCoordinates, coordinate);\r\n    }\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Make a complete copy of the geometry.\r\n   * @return {!LineString} Clone.\r\n   * @api\r\n   */\r\n  clone() {\r\n    const lineString = new LineString(\r\n      this.flatCoordinates.slice(),\r\n      this.layout\r\n    );\r\n    lineString.applyProperties(this);\r\n    return lineString;\r\n  }\r\n\r\n  /**\r\n   * @param {number} x X.\r\n   * @param {number} y Y.\r\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\r\n   * @param {number} minSquaredDistance Minimum squared distance.\r\n   * @return {number} Minimum squared distance.\r\n   */\r\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\r\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\r\n      return minSquaredDistance;\r\n    }\r\n    if (this.maxDeltaRevision_ != this.getRevision()) {\r\n      this.maxDelta_ = Math.sqrt(\r\n        maxSquaredDelta(\r\n          this.flatCoordinates,\r\n          0,\r\n          this.flatCoordinates.length,\r\n          this.stride,\r\n          0\r\n        )\r\n      );\r\n      this.maxDeltaRevision_ = this.getRevision();\r\n    }\r\n    return assignClosestPoint(\r\n      this.flatCoordinates,\r\n      0,\r\n      this.flatCoordinates.length,\r\n      this.stride,\r\n      this.maxDelta_,\r\n      false,\r\n      x,\r\n      y,\r\n      closestPoint,\r\n      minSquaredDistance\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Iterate over each segment, calling the provided callback.\r\n   * If the callback returns a truthy value the function returns that\r\n   * value immediately. Otherwise the function returns `false`.\r\n   *\r\n   * @param {function(this: S, import(\"../coordinate.js\").Coordinate, import(\"../coordinate.js\").Coordinate): T} callback Function\r\n   *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.\r\n   * @return {T|boolean} Value.\r\n   * @template T,S\r\n   * @api\r\n   */\r\n  forEachSegment(callback) {\r\n    return forEachSegment(\r\n      this.flatCoordinates,\r\n      0,\r\n      this.flatCoordinates.length,\r\n      this.stride,\r\n      callback\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Returns the coordinate at `m` using linear interpolation, or `null` if no\r\n   * such coordinate exists.\r\n   *\r\n   * `extrapolate` controls extrapolation beyond the range of Ms in the\r\n   * MultiLineString. If `extrapolate` is `true` then Ms less than the first\r\n   * M will return the first coordinate and Ms greater than the last M will\r\n   * return the last coordinate.\r\n   *\r\n   * @param {number} m M.\r\n   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.\r\n   * @return {import(\"../coordinate.js\").Coordinate|null} Coordinate.\r\n   * @api\r\n   */\r\n  getCoordinateAtM(m, extrapolate) {\r\n    if (this.layout != 'XYM' && this.layout != 'XYZM') {\r\n      return null;\r\n    }\r\n    extrapolate = extrapolate !== undefined ? extrapolate : false;\r\n    return lineStringCoordinateAtM(\r\n      this.flatCoordinates,\r\n      0,\r\n      this.flatCoordinates.length,\r\n      this.stride,\r\n      m,\r\n      extrapolate\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return the coordinates of the linestring.\r\n   * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\r\n   * @api\r\n   */\r\n  getCoordinates() {\r\n    return inflateCoordinates(\r\n      this.flatCoordinates,\r\n      0,\r\n      this.flatCoordinates.length,\r\n      this.stride\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return the coordinate at the provided fraction along the linestring.\r\n   * The `fraction` is a number between 0 and 1, where 0 is the start of the\r\n   * linestring and 1 is the end.\r\n   * @param {number} fraction Fraction.\r\n   * @param {import(\"../coordinate.js\").Coordinate} [dest] Optional coordinate whose values will\r\n   *     be modified. If not provided, a new coordinate will be returned.\r\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinate of the interpolated point.\r\n   * @api\r\n   */\r\n  getCoordinateAt(fraction, dest) {\r\n    return interpolatePoint(\r\n      this.flatCoordinates,\r\n      0,\r\n      this.flatCoordinates.length,\r\n      this.stride,\r\n      fraction,\r\n      dest,\r\n      this.stride\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return the length of the linestring on projected plane.\r\n   * @return {number} Length (on projected plane).\r\n   * @api\r\n   */\r\n  getLength() {\r\n    return lineStringLength(\r\n      this.flatCoordinates,\r\n      0,\r\n      this.flatCoordinates.length,\r\n      this.stride\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @return {Array<number>} Flat midpoint.\r\n   */\r\n  getFlatMidpoint() {\r\n    if (this.flatMidpointRevision_ != this.getRevision()) {\r\n      this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);\r\n      this.flatMidpointRevision_ = this.getRevision();\r\n    }\r\n    return this.flatMidpoint_;\r\n  }\r\n\r\n  /**\r\n   * @param {number} squaredTolerance Squared tolerance.\r\n   * @return {LineString} Simplified LineString.\r\n   * @protected\r\n   */\r\n  getSimplifiedGeometryInternal(squaredTolerance) {\r\n    const simplifiedFlatCoordinates = [];\r\n    simplifiedFlatCoordinates.length = douglasPeucker(\r\n      this.flatCoordinates,\r\n      0,\r\n      this.flatCoordinates.length,\r\n      this.stride,\r\n      squaredTolerance,\r\n      simplifiedFlatCoordinates,\r\n      0\r\n    );\r\n    return new LineString(simplifiedFlatCoordinates, 'XY');\r\n  }\r\n\r\n  /**\r\n   * Get the type of this geometry.\r\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\r\n   * @api\r\n   */\r\n  getType() {\r\n    return 'LineString';\r\n  }\r\n\r\n  /**\r\n   * Test if the geometry and the passed extent intersect.\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @return {boolean} `true` if the geometry and the extent intersect.\r\n   * @api\r\n   */\r\n  intersectsExtent(extent) {\r\n    return intersectsLineString(\r\n      this.flatCoordinates,\r\n      0,\r\n      this.flatCoordinates.length,\r\n      this.stride,\r\n      extent\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Set the coordinates of the linestring.\r\n   * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\r\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\r\n   * @api\r\n   */\r\n  setCoordinates(coordinates, layout) {\r\n    this.setLayout(layout, coordinates, 1);\r\n    if (!this.flatCoordinates) {\r\n      this.flatCoordinates = [];\r\n    }\r\n    this.flatCoordinates.length = deflateCoordinates(\r\n      this.flatCoordinates,\r\n      0,\r\n      coordinates,\r\n      this.stride\r\n    );\r\n    this.changed();\r\n  }\r\n}\r\n\r\nexport default LineString;\r\n", "/**\r\n * @module ol/geom/MultiLineString\r\n */\r\nimport LineString from './LineString.js';\r\nimport SimpleGeometry from './SimpleGeometry.js';\r\nimport {arrayMaxSquaredDelta, assignClosestArrayPoint} from './flat/closest.js';\r\nimport {closestSquaredDistanceXY} from '../extent.js';\r\nimport {deflateCoordinatesArray} from './flat/deflate.js';\r\nimport {douglasPeuckerArray} from './flat/simplify.js';\r\nimport {extend} from '../array.js';\r\nimport {inflateCoordinatesArray} from './flat/inflate.js';\r\nimport {\r\n  interpolatePoint,\r\n  lineStringsCoordinateAtM,\r\n} from './flat/interpolate.js';\r\nimport {intersectsLineStringArray} from './flat/intersectsextent.js';\r\n\r\n/**\r\n * @classdesc\r\n * Multi-linestring geometry.\r\n *\r\n * @api\r\n */\r\nclass MultiLineString extends SimpleGeometry {\r\n  /**\r\n   * @param {Array<Array<import(\"../coordinate.js\").Coordinate>|LineString>|Array<number>} coordinates\r\n   *     Coordinates or LineString geometries. (For internal use, flat coordinates in\r\n   *     combination with `layout` and `ends` are also accepted.)\r\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\r\n   * @param {Array<number>} [ends] Flat coordinate ends for internal use.\r\n   */\r\n  constructor(coordinates, layout, ends) {\r\n    super();\r\n\r\n    /**\r\n     * @type {Array<number>}\r\n     * @private\r\n     */\r\n    this.ends_ = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.maxDelta_ = -1;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.maxDeltaRevision_ = -1;\r\n\r\n    if (Array.isArray(coordinates[0])) {\r\n      this.setCoordinates(\r\n        /** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */ (\r\n          coordinates\r\n        ),\r\n        layout\r\n      );\r\n    } else if (layout !== undefined && ends) {\r\n      this.setFlatCoordinates(\r\n        layout,\r\n        /** @type {Array<number>} */ (coordinates)\r\n      );\r\n      this.ends_ = ends;\r\n    } else {\r\n      let layout = this.getLayout();\r\n      const lineStrings = /** @type {Array<LineString>} */ (coordinates);\r\n      const flatCoordinates = [];\r\n      const ends = [];\r\n      for (let i = 0, ii = lineStrings.length; i < ii; ++i) {\r\n        const lineString = lineStrings[i];\r\n        if (i === 0) {\r\n          layout = lineString.getLayout();\r\n        }\r\n        extend(flatCoordinates, lineString.getFlatCoordinates());\r\n        ends.push(flatCoordinates.length);\r\n      }\r\n      this.setFlatCoordinates(layout, flatCoordinates);\r\n      this.ends_ = ends;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Append the passed linestring to the multilinestring.\r\n   * @param {LineString} lineString LineString.\r\n   * @api\r\n   */\r\n  appendLineString(lineString) {\r\n    if (!this.flatCoordinates) {\r\n      this.flatCoordinates = lineString.getFlatCoordinates().slice();\r\n    } else {\r\n      extend(this.flatCoordinates, lineString.getFlatCoordinates().slice());\r\n    }\r\n    this.ends_.push(this.flatCoordinates.length);\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Make a complete copy of the geometry.\r\n   * @return {!MultiLineString} Clone.\r\n   * @api\r\n   */\r\n  clone() {\r\n    const multiLineString = new MultiLineString(\r\n      this.flatCoordinates.slice(),\r\n      this.layout,\r\n      this.ends_.slice()\r\n    );\r\n    multiLineString.applyProperties(this);\r\n    return multiLineString;\r\n  }\r\n\r\n  /**\r\n   * @param {number} x X.\r\n   * @param {number} y Y.\r\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\r\n   * @param {number} minSquaredDistance Minimum squared distance.\r\n   * @return {number} Minimum squared distance.\r\n   */\r\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\r\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\r\n      return minSquaredDistance;\r\n    }\r\n    if (this.maxDeltaRevision_ != this.getRevision()) {\r\n      this.maxDelta_ = Math.sqrt(\r\n        arrayMaxSquaredDelta(\r\n          this.flatCoordinates,\r\n          0,\r\n          this.ends_,\r\n          this.stride,\r\n          0\r\n        )\r\n      );\r\n      this.maxDeltaRevision_ = this.getRevision();\r\n    }\r\n    return assignClosestArrayPoint(\r\n      this.flatCoordinates,\r\n      0,\r\n      this.ends_,\r\n      this.stride,\r\n      this.maxDelta_,\r\n      false,\r\n      x,\r\n      y,\r\n      closestPoint,\r\n      minSquaredDistance\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Returns the coordinate at `m` using linear interpolation, or `null` if no\r\n   * such coordinate exists.\r\n   *\r\n   * `extrapolate` controls extrapolation beyond the range of Ms in the\r\n   * MultiLineString. If `extrapolate` is `true` then Ms less than the first\r\n   * M will return the first coordinate and Ms greater than the last M will\r\n   * return the last coordinate.\r\n   *\r\n   * `interpolate` controls interpolation between consecutive LineStrings\r\n   * within the MultiLineString. If `interpolate` is `true` the coordinates\r\n   * will be linearly interpolated between the last coordinate of one LineString\r\n   * and the first coordinate of the next LineString.  If `interpolate` is\r\n   * `false` then the function will return `null` for Ms falling between\r\n   * LineStrings.\r\n   *\r\n   * @param {number} m M.\r\n   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.\r\n   * @param {boolean} [interpolate] Interpolate. Default is `false`.\r\n   * @return {import(\"../coordinate.js\").Coordinate|null} Coordinate.\r\n   * @api\r\n   */\r\n  getCoordinateAtM(m, extrapolate, interpolate) {\r\n    if (\r\n      (this.layout != 'XYM' && this.layout != 'XYZM') ||\r\n      this.flatCoordinates.length === 0\r\n    ) {\r\n      return null;\r\n    }\r\n    extrapolate = extrapolate !== undefined ? extrapolate : false;\r\n    interpolate = interpolate !== undefined ? interpolate : false;\r\n    return lineStringsCoordinateAtM(\r\n      this.flatCoordinates,\r\n      0,\r\n      this.ends_,\r\n      this.stride,\r\n      m,\r\n      extrapolate,\r\n      interpolate\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return the coordinates of the multilinestring.\r\n   * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\r\n   * @api\r\n   */\r\n  getCoordinates() {\r\n    return inflateCoordinatesArray(\r\n      this.flatCoordinates,\r\n      0,\r\n      this.ends_,\r\n      this.stride\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @return {Array<number>} Ends.\r\n   */\r\n  getEnds() {\r\n    return this.ends_;\r\n  }\r\n\r\n  /**\r\n   * Return the linestring at the specified index.\r\n   * @param {number} index Index.\r\n   * @return {LineString} LineString.\r\n   * @api\r\n   */\r\n  getLineString(index) {\r\n    if (index < 0 || this.ends_.length <= index) {\r\n      return null;\r\n    }\r\n    return new LineString(\r\n      this.flatCoordinates.slice(\r\n        index === 0 ? 0 : this.ends_[index - 1],\r\n        this.ends_[index]\r\n      ),\r\n      this.layout\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return the linestrings of this multilinestring.\r\n   * @return {Array<LineString>} LineStrings.\r\n   * @api\r\n   */\r\n  getLineStrings() {\r\n    const flatCoordinates = this.flatCoordinates;\r\n    const ends = this.ends_;\r\n    const layout = this.layout;\r\n    /** @type {Array<LineString>} */\r\n    const lineStrings = [];\r\n    let offset = 0;\r\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n      const end = ends[i];\r\n      const lineString = new LineString(\r\n        flatCoordinates.slice(offset, end),\r\n        layout\r\n      );\r\n      lineStrings.push(lineString);\r\n      offset = end;\r\n    }\r\n    return lineStrings;\r\n  }\r\n\r\n  /**\r\n   * @return {Array<number>} Flat midpoints.\r\n   */\r\n  getFlatMidpoints() {\r\n    const midpoints = [];\r\n    const flatCoordinates = this.flatCoordinates;\r\n    let offset = 0;\r\n    const ends = this.ends_;\r\n    const stride = this.stride;\r\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n      const end = ends[i];\r\n      const midpoint = interpolatePoint(\r\n        flatCoordinates,\r\n        offset,\r\n        end,\r\n        stride,\r\n        0.5\r\n      );\r\n      extend(midpoints, midpoint);\r\n      offset = end;\r\n    }\r\n    return midpoints;\r\n  }\r\n\r\n  /**\r\n   * @param {number} squaredTolerance Squared tolerance.\r\n   * @return {MultiLineString} Simplified MultiLineString.\r\n   * @protected\r\n   */\r\n  getSimplifiedGeometryInternal(squaredTolerance) {\r\n    const simplifiedFlatCoordinates = [];\r\n    const simplifiedEnds = [];\r\n    simplifiedFlatCoordinates.length = douglasPeuckerArray(\r\n      this.flatCoordinates,\r\n      0,\r\n      this.ends_,\r\n      this.stride,\r\n      squaredTolerance,\r\n      simplifiedFlatCoordinates,\r\n      0,\r\n      simplifiedEnds\r\n    );\r\n    return new MultiLineString(simplifiedFlatCoordinates, 'XY', simplifiedEnds);\r\n  }\r\n\r\n  /**\r\n   * Get the type of this geometry.\r\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\r\n   * @api\r\n   */\r\n  getType() {\r\n    return 'MultiLineString';\r\n  }\r\n\r\n  /**\r\n   * Test if the geometry and the passed extent intersect.\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @return {boolean} `true` if the geometry and the extent intersect.\r\n   * @api\r\n   */\r\n  intersectsExtent(extent) {\r\n    return intersectsLineStringArray(\r\n      this.flatCoordinates,\r\n      0,\r\n      this.ends_,\r\n      this.stride,\r\n      extent\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Set the coordinates of the multilinestring.\r\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\r\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\r\n   * @api\r\n   */\r\n  setCoordinates(coordinates, layout) {\r\n    this.setLayout(layout, coordinates, 2);\r\n    if (!this.flatCoordinates) {\r\n      this.flatCoordinates = [];\r\n    }\r\n    const ends = deflateCoordinatesArray(\r\n      this.flatCoordinates,\r\n      0,\r\n      coordinates,\r\n      this.stride,\r\n      this.ends_\r\n    );\r\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\r\n    this.changed();\r\n  }\r\n}\r\n\r\nexport default MultiLineString;\r\n", "/**\r\n * @module ol/geom/MultiPoint\r\n */\r\nimport Point from './Point.js';\r\nimport SimpleGeometry from './SimpleGeometry.js';\r\nimport {closestSquaredDistanceXY, containsXY} from '../extent.js';\r\nimport {deflateCoordinates} from './flat/deflate.js';\r\nimport {extend} from '../array.js';\r\nimport {inflateCoordinates} from './flat/inflate.js';\r\nimport {squaredDistance as squaredDx} from '../math.js';\r\n\r\n/**\r\n * @classdesc\r\n * Multi-point geometry.\r\n *\r\n * @api\r\n */\r\nclass MultiPoint extends SimpleGeometry {\r\n  /**\r\n   * @param {Array<import(\"../coordinate.js\").Coordinate>|Array<number>} coordinates Coordinates.\r\n   *     For internal use, flat coordinates in combination with `layout` are also accepted.\r\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\r\n   */\r\n  constructor(coordinates, layout) {\r\n    super();\r\n    if (layout && !Array.isArray(coordinates[0])) {\r\n      this.setFlatCoordinates(\r\n        layout,\r\n        /** @type {Array<number>} */ (coordinates)\r\n      );\r\n    } else {\r\n      this.setCoordinates(\r\n        /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (\r\n          coordinates\r\n        ),\r\n        layout\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Append the passed point to this multipoint.\r\n   * @param {Point} point Point.\r\n   * @api\r\n   */\r\n  appendPoint(point) {\r\n    if (!this.flatCoordinates) {\r\n      this.flatCoordinates = point.getFlatCoordinates().slice();\r\n    } else {\r\n      extend(this.flatCoordinates, point.getFlatCoordinates());\r\n    }\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Make a complete copy of the geometry.\r\n   * @return {!MultiPoint} Clone.\r\n   * @api\r\n   */\r\n  clone() {\r\n    const multiPoint = new MultiPoint(\r\n      this.flatCoordinates.slice(),\r\n      this.layout\r\n    );\r\n    multiPoint.applyProperties(this);\r\n    return multiPoint;\r\n  }\r\n\r\n  /**\r\n   * @param {number} x X.\r\n   * @param {number} y Y.\r\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\r\n   * @param {number} minSquaredDistance Minimum squared distance.\r\n   * @return {number} Minimum squared distance.\r\n   */\r\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\r\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\r\n      return minSquaredDistance;\r\n    }\r\n    const flatCoordinates = this.flatCoordinates;\r\n    const stride = this.stride;\r\n    for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\r\n      const squaredDistance = squaredDx(\r\n        x,\r\n        y,\r\n        flatCoordinates[i],\r\n        flatCoordinates[i + 1]\r\n      );\r\n      if (squaredDistance < minSquaredDistance) {\r\n        minSquaredDistance = squaredDistance;\r\n        for (let j = 0; j < stride; ++j) {\r\n          closestPoint[j] = flatCoordinates[i + j];\r\n        }\r\n        closestPoint.length = stride;\r\n      }\r\n    }\r\n    return minSquaredDistance;\r\n  }\r\n\r\n  /**\r\n   * Return the coordinates of the multipoint.\r\n   * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\r\n   * @api\r\n   */\r\n  getCoordinates() {\r\n    return inflateCoordinates(\r\n      this.flatCoordinates,\r\n      0,\r\n      this.flatCoordinates.length,\r\n      this.stride\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return the point at the specified index.\r\n   * @param {number} index Index.\r\n   * @return {Point} Point.\r\n   * @api\r\n   */\r\n  getPoint(index) {\r\n    const n = !this.flatCoordinates\r\n      ? 0\r\n      : this.flatCoordinates.length / this.stride;\r\n    if (index < 0 || n <= index) {\r\n      return null;\r\n    }\r\n    return new Point(\r\n      this.flatCoordinates.slice(\r\n        index * this.stride,\r\n        (index + 1) * this.stride\r\n      ),\r\n      this.layout\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return the points of this multipoint.\r\n   * @return {Array<Point>} Points.\r\n   * @api\r\n   */\r\n  getPoints() {\r\n    const flatCoordinates = this.flatCoordinates;\r\n    const layout = this.layout;\r\n    const stride = this.stride;\r\n    /** @type {Array<Point>} */\r\n    const points = [];\r\n    for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\r\n      const point = new Point(flatCoordinates.slice(i, i + stride), layout);\r\n      points.push(point);\r\n    }\r\n    return points;\r\n  }\r\n\r\n  /**\r\n   * Get the type of this geometry.\r\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\r\n   * @api\r\n   */\r\n  getType() {\r\n    return 'MultiPoint';\r\n  }\r\n\r\n  /**\r\n   * Test if the geometry and the passed extent intersect.\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @return {boolean} `true` if the geometry and the extent intersect.\r\n   * @api\r\n   */\r\n  intersectsExtent(extent) {\r\n    const flatCoordinates = this.flatCoordinates;\r\n    const stride = this.stride;\r\n    for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\r\n      const x = flatCoordinates[i];\r\n      const y = flatCoordinates[i + 1];\r\n      if (containsXY(extent, x, y)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Set the coordinates of the multipoint.\r\n   * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\r\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\r\n   * @api\r\n   */\r\n  setCoordinates(coordinates, layout) {\r\n    this.setLayout(layout, coordinates, 1);\r\n    if (!this.flatCoordinates) {\r\n      this.flatCoordinates = [];\r\n    }\r\n    this.flatCoordinates.length = deflateCoordinates(\r\n      this.flatCoordinates,\r\n      0,\r\n      coordinates,\r\n      this.stride\r\n    );\r\n    this.changed();\r\n  }\r\n}\r\n\r\nexport default MultiPoint;\r\n", "/**\r\n * @module ol/geom/flat/center\r\n */\r\nimport {createEmpty, createOrUpdateFromFlatCoordinates} from '../../extent.js';\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Endss.\r\n * @param {number} stride Stride.\r\n * @return {Array<number>} Flat centers.\r\n */\r\nexport function linearRingss(flatCoordinates, offset, endss, stride) {\r\n  const flatCenters = [];\r\n  let extent = createEmpty();\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    const ends = endss[i];\r\n    extent = createOrUpdateFromFlatCoordinates(\r\n      flatCoordinates,\r\n      offset,\r\n      ends[0],\r\n      stride\r\n    );\r\n    flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  return flatCenters;\r\n}\r\n", "/**\r\n * @module ol/geom/MultiPolygon\r\n */\r\nimport MultiPoint from './MultiPoint.js';\r\nimport Polygon from './Polygon.js';\r\nimport SimpleGeometry from './SimpleGeometry.js';\r\nimport {\r\n  assignClosestMultiArrayPoint,\r\n  multiArrayMaxSquaredDelta,\r\n} from './flat/closest.js';\r\nimport {closestSquaredDistanceXY} from '../extent.js';\r\nimport {deflateMultiCoordinatesArray} from './flat/deflate.js';\r\nimport {extend} from '../array.js';\r\nimport {getInteriorPointsOfMultiArray} from './flat/interiorpoint.js';\r\nimport {inflateMultiCoordinatesArray} from './flat/inflate.js';\r\nimport {intersectsLinearRingMultiArray} from './flat/intersectsextent.js';\r\nimport {\r\n  linearRingssAreOriented,\r\n  orientLinearRingsArray,\r\n} from './flat/orient.js';\r\nimport {linearRingss as linearRingssArea} from './flat/area.js';\r\nimport {linearRingss as linearRingssCenter} from './flat/center.js';\r\nimport {linearRingssContainsXY} from './flat/contains.js';\r\nimport {quantizeMultiArray} from './flat/simplify.js';\r\n\r\n/**\r\n * @classdesc\r\n * Multi-polygon geometry.\r\n *\r\n * @api\r\n */\r\nclass MultiPolygon extends SimpleGeometry {\r\n  /**\r\n   * @param {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.\r\n   *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.\r\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\r\n   * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.\r\n   */\r\n  constructor(coordinates, layout, endss) {\r\n    super();\r\n\r\n    /**\r\n     * @type {Array<Array<number>>}\r\n     * @private\r\n     */\r\n    this.endss_ = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.flatInteriorPointsRevision_ = -1;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<number>}\r\n     */\r\n    this.flatInteriorPoints_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.maxDelta_ = -1;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.maxDeltaRevision_ = -1;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.orientedRevision_ = -1;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<number>}\r\n     */\r\n    this.orientedFlatCoordinates_ = null;\r\n\r\n    if (!endss && !Array.isArray(coordinates[0])) {\r\n      let thisLayout = this.getLayout();\r\n      const polygons = /** @type {Array<Polygon>} */ (coordinates);\r\n      const flatCoordinates = [];\r\n      const thisEndss = [];\r\n      for (let i = 0, ii = polygons.length; i < ii; ++i) {\r\n        const polygon = polygons[i];\r\n        if (i === 0) {\r\n          thisLayout = polygon.getLayout();\r\n        }\r\n        const offset = flatCoordinates.length;\r\n        const ends = polygon.getEnds();\r\n        for (let j = 0, jj = ends.length; j < jj; ++j) {\r\n          ends[j] += offset;\r\n        }\r\n        extend(flatCoordinates, polygon.getFlatCoordinates());\r\n        thisEndss.push(ends);\r\n      }\r\n      layout = thisLayout;\r\n      coordinates = flatCoordinates;\r\n      endss = thisEndss;\r\n    }\r\n    if (layout !== undefined && endss) {\r\n      this.setFlatCoordinates(\r\n        layout,\r\n        /** @type {Array<number>} */ (coordinates)\r\n      );\r\n      this.endss_ = endss;\r\n    } else {\r\n      this.setCoordinates(\r\n        /** @type {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} */ (\r\n          coordinates\r\n        ),\r\n        layout\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Append the passed polygon to this multipolygon.\r\n   * @param {Polygon} polygon Polygon.\r\n   * @api\r\n   */\r\n  appendPolygon(polygon) {\r\n    /** @type {Array<number>} */\r\n    let ends;\r\n    if (!this.flatCoordinates) {\r\n      this.flatCoordinates = polygon.getFlatCoordinates().slice();\r\n      ends = polygon.getEnds().slice();\r\n      this.endss_.push();\r\n    } else {\r\n      const offset = this.flatCoordinates.length;\r\n      extend(this.flatCoordinates, polygon.getFlatCoordinates());\r\n      ends = polygon.getEnds().slice();\r\n      for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n        ends[i] += offset;\r\n      }\r\n    }\r\n    this.endss_.push(ends);\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Make a complete copy of the geometry.\r\n   * @return {!MultiPolygon} Clone.\r\n   * @api\r\n   */\r\n  clone() {\r\n    const len = this.endss_.length;\r\n    const newEndss = new Array(len);\r\n    for (let i = 0; i < len; ++i) {\r\n      newEndss[i] = this.endss_[i].slice();\r\n    }\r\n\r\n    const multiPolygon = new MultiPolygon(\r\n      this.flatCoordinates.slice(),\r\n      this.layout,\r\n      newEndss\r\n    );\r\n    multiPolygon.applyProperties(this);\r\n\r\n    return multiPolygon;\r\n  }\r\n\r\n  /**\r\n   * @param {number} x X.\r\n   * @param {number} y Y.\r\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\r\n   * @param {number} minSquaredDistance Minimum squared distance.\r\n   * @return {number} Minimum squared distance.\r\n   */\r\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\r\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\r\n      return minSquaredDistance;\r\n    }\r\n    if (this.maxDeltaRevision_ != this.getRevision()) {\r\n      this.maxDelta_ = Math.sqrt(\r\n        multiArrayMaxSquaredDelta(\r\n          this.flatCoordinates,\r\n          0,\r\n          this.endss_,\r\n          this.stride,\r\n          0\r\n        )\r\n      );\r\n      this.maxDeltaRevision_ = this.getRevision();\r\n    }\r\n    return assignClosestMultiArrayPoint(\r\n      this.getOrientedFlatCoordinates(),\r\n      0,\r\n      this.endss_,\r\n      this.stride,\r\n      this.maxDelta_,\r\n      true,\r\n      x,\r\n      y,\r\n      closestPoint,\r\n      minSquaredDistance\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {number} x X.\r\n   * @param {number} y Y.\r\n   * @return {boolean} Contains (x, y).\r\n   */\r\n  containsXY(x, y) {\r\n    return linearRingssContainsXY(\r\n      this.getOrientedFlatCoordinates(),\r\n      0,\r\n      this.endss_,\r\n      this.stride,\r\n      x,\r\n      y\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return the area of the multipolygon on projected plane.\r\n   * @return {number} Area (on projected plane).\r\n   * @api\r\n   */\r\n  getArea() {\r\n    return linearRingssArea(\r\n      this.getOrientedFlatCoordinates(),\r\n      0,\r\n      this.endss_,\r\n      this.stride\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get the coordinate array for this geometry.  This array has the structure\r\n   * of a GeoJSON coordinate array for multi-polygons.\r\n   *\r\n   * @param {boolean} [right] Orient coordinates according to the right-hand\r\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\r\n   *     If `false`, coordinates will be oriented according to the left-hand rule\r\n   *     (clockwise for exterior and counter-clockwise for interior rings).\r\n   *     By default, coordinate orientation will depend on how the geometry was\r\n   *     constructed.\r\n   * @return {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} Coordinates.\r\n   * @api\r\n   */\r\n  getCoordinates(right) {\r\n    let flatCoordinates;\r\n    if (right !== undefined) {\r\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\r\n      orientLinearRingsArray(\r\n        flatCoordinates,\r\n        0,\r\n        this.endss_,\r\n        this.stride,\r\n        right\r\n      );\r\n    } else {\r\n      flatCoordinates = this.flatCoordinates;\r\n    }\r\n\r\n    return inflateMultiCoordinatesArray(\r\n      flatCoordinates,\r\n      0,\r\n      this.endss_,\r\n      this.stride\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @return {Array<Array<number>>} Endss.\r\n   */\r\n  getEndss() {\r\n    return this.endss_;\r\n  }\r\n\r\n  /**\r\n   * @return {Array<number>} Flat interior points.\r\n   */\r\n  getFlatInteriorPoints() {\r\n    if (this.flatInteriorPointsRevision_ != this.getRevision()) {\r\n      const flatCenters = linearRingssCenter(\r\n        this.flatCoordinates,\r\n        0,\r\n        this.endss_,\r\n        this.stride\r\n      );\r\n      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(\r\n        this.getOrientedFlatCoordinates(),\r\n        0,\r\n        this.endss_,\r\n        this.stride,\r\n        flatCenters\r\n      );\r\n      this.flatInteriorPointsRevision_ = this.getRevision();\r\n    }\r\n    return this.flatInteriorPoints_;\r\n  }\r\n\r\n  /**\r\n   * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.\r\n   * @return {MultiPoint} Interior points as XYM coordinates, where M is\r\n   * the length of the horizontal intersection that the point belongs to.\r\n   * @api\r\n   */\r\n  getInteriorPoints() {\r\n    return new MultiPoint(this.getFlatInteriorPoints().slice(), 'XYM');\r\n  }\r\n\r\n  /**\r\n   * @return {Array<number>} Oriented flat coordinates.\r\n   */\r\n  getOrientedFlatCoordinates() {\r\n    if (this.orientedRevision_ != this.getRevision()) {\r\n      const flatCoordinates = this.flatCoordinates;\r\n      if (\r\n        linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)\r\n      ) {\r\n        this.orientedFlatCoordinates_ = flatCoordinates;\r\n      } else {\r\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\r\n        this.orientedFlatCoordinates_.length = orientLinearRingsArray(\r\n          this.orientedFlatCoordinates_,\r\n          0,\r\n          this.endss_,\r\n          this.stride\r\n        );\r\n      }\r\n      this.orientedRevision_ = this.getRevision();\r\n    }\r\n    return this.orientedFlatCoordinates_;\r\n  }\r\n\r\n  /**\r\n   * @param {number} squaredTolerance Squared tolerance.\r\n   * @return {MultiPolygon} Simplified MultiPolygon.\r\n   * @protected\r\n   */\r\n  getSimplifiedGeometryInternal(squaredTolerance) {\r\n    const simplifiedFlatCoordinates = [];\r\n    const simplifiedEndss = [];\r\n    simplifiedFlatCoordinates.length = quantizeMultiArray(\r\n      this.flatCoordinates,\r\n      0,\r\n      this.endss_,\r\n      this.stride,\r\n      Math.sqrt(squaredTolerance),\r\n      simplifiedFlatCoordinates,\r\n      0,\r\n      simplifiedEndss\r\n    );\r\n    return new MultiPolygon(simplifiedFlatCoordinates, 'XY', simplifiedEndss);\r\n  }\r\n\r\n  /**\r\n   * Return the polygon at the specified index.\r\n   * @param {number} index Index.\r\n   * @return {Polygon} Polygon.\r\n   * @api\r\n   */\r\n  getPolygon(index) {\r\n    if (index < 0 || this.endss_.length <= index) {\r\n      return null;\r\n    }\r\n    let offset;\r\n    if (index === 0) {\r\n      offset = 0;\r\n    } else {\r\n      const prevEnds = this.endss_[index - 1];\r\n      offset = prevEnds[prevEnds.length - 1];\r\n    }\r\n    const ends = this.endss_[index].slice();\r\n    const end = ends[ends.length - 1];\r\n    if (offset !== 0) {\r\n      for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n        ends[i] -= offset;\r\n      }\r\n    }\r\n    return new Polygon(\r\n      this.flatCoordinates.slice(offset, end),\r\n      this.layout,\r\n      ends\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return the polygons of this multipolygon.\r\n   * @return {Array<Polygon>} Polygons.\r\n   * @api\r\n   */\r\n  getPolygons() {\r\n    const layout = this.layout;\r\n    const flatCoordinates = this.flatCoordinates;\r\n    const endss = this.endss_;\r\n    const polygons = [];\r\n    let offset = 0;\r\n    for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n      const ends = endss[i].slice();\r\n      const end = ends[ends.length - 1];\r\n      if (offset !== 0) {\r\n        for (let j = 0, jj = ends.length; j < jj; ++j) {\r\n          ends[j] -= offset;\r\n        }\r\n      }\r\n      const polygon = new Polygon(\r\n        flatCoordinates.slice(offset, end),\r\n        layout,\r\n        ends\r\n      );\r\n      polygons.push(polygon);\r\n      offset = end;\r\n    }\r\n    return polygons;\r\n  }\r\n\r\n  /**\r\n   * Get the type of this geometry.\r\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\r\n   * @api\r\n   */\r\n  getType() {\r\n    return 'MultiPolygon';\r\n  }\r\n\r\n  /**\r\n   * Test if the geometry and the passed extent intersect.\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @return {boolean} `true` if the geometry and the extent intersect.\r\n   * @api\r\n   */\r\n  intersectsExtent(extent) {\r\n    return intersectsLinearRingMultiArray(\r\n      this.getOrientedFlatCoordinates(),\r\n      0,\r\n      this.endss_,\r\n      this.stride,\r\n      extent\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Set the coordinates of the multipolygon.\r\n   * @param {!Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} coordinates Coordinates.\r\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\r\n   * @api\r\n   */\r\n  setCoordinates(coordinates, layout) {\r\n    this.setLayout(layout, coordinates, 3);\r\n    if (!this.flatCoordinates) {\r\n      this.flatCoordinates = [];\r\n    }\r\n    const endss = deflateMultiCoordinatesArray(\r\n      this.flatCoordinates,\r\n      0,\r\n      coordinates,\r\n      this.stride,\r\n      this.endss_\r\n    );\r\n    if (endss.length === 0) {\r\n      this.flatCoordinates.length = 0;\r\n    } else {\r\n      const lastEnds = endss[endss.length - 1];\r\n      this.flatCoordinates.length =\r\n        lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];\r\n    }\r\n    this.changed();\r\n  }\r\n}\r\n\r\nexport default MultiPolygon;\r\n"],
  "mappings": "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",
  "names": ["squaredDistance", "extend", "layout", "ends", "squaredDistance", "linearRingss", "linearRingss"]
}
