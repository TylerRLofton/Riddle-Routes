import {
  Control_default,
  EventType_default as EventType_default2
} from "./chunk-GI5ZKXKH.js";
import {
  easeOut
} from "./chunk-X5K3DKGA.js";
import {
  CLASS_CONTROL,
  CLASS_UNSELECTABLE
} from "./chunk-4D36UE7E.js";
import {
  EventType_default,
  listen,
  stopPropagation,
  unlistenByKey
} from "./chunk-IHQ4MM4P.js";
import {
  clamp
} from "./chunk-O5DQMQHB.js";

// node_modules/ol/control/ZoomSlider.js
var Direction = {
  VERTICAL: 0,
  HORIZONTAL: 1
};
var ZoomSlider = class extends Control_default {
  constructor(options) {
    options = options ? options : {};
    super({
      element: document.createElement("div"),
      render: options.render
    });
    this.dragListenerKeys_ = [];
    this.currentResolution_ = void 0;
    this.direction_ = Direction.VERTICAL;
    this.dragging_;
    this.heightLimit_ = 0;
    this.widthLimit_ = 0;
    this.startX_;
    this.startY_;
    this.thumbSize_ = null;
    this.sliderInitialized_ = false;
    this.duration_ = options.duration !== void 0 ? options.duration : 200;
    const className = options.className !== void 0 ? options.className : "ol-zoomslider";
    const thumbElement = document.createElement("button");
    thumbElement.setAttribute("type", "button");
    thumbElement.className = className + "-thumb " + CLASS_UNSELECTABLE;
    const containerElement = this.element;
    containerElement.className = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
    containerElement.appendChild(thumbElement);
    containerElement.addEventListener(
      EventType_default2.POINTERDOWN,
      this.handleDraggerStart_.bind(this),
      false
    );
    containerElement.addEventListener(
      EventType_default2.POINTERMOVE,
      this.handleDraggerDrag_.bind(this),
      false
    );
    containerElement.addEventListener(
      EventType_default2.POINTERUP,
      this.handleDraggerEnd_.bind(this),
      false
    );
    containerElement.addEventListener(
      EventType_default.CLICK,
      this.handleContainerClick_.bind(this),
      false
    );
    thumbElement.addEventListener(EventType_default.CLICK, stopPropagation, false);
  }
  setMap(map) {
    super.setMap(map);
    if (map) {
      map.render();
    }
  }
  initSlider_() {
    const container = this.element;
    let containerWidth = container.offsetWidth;
    let containerHeight = container.offsetHeight;
    if (containerWidth === 0 && containerHeight === 0) {
      return this.sliderInitialized_ = false;
    }
    const containerStyle = getComputedStyle(container);
    containerWidth -= parseFloat(containerStyle["paddingRight"]) + parseFloat(containerStyle["paddingLeft"]);
    containerHeight -= parseFloat(containerStyle["paddingTop"]) + parseFloat(containerStyle["paddingBottom"]);
    const thumb = container.firstElementChild;
    const thumbStyle = getComputedStyle(thumb);
    const thumbWidth = thumb.offsetWidth + parseFloat(thumbStyle["marginRight"]) + parseFloat(thumbStyle["marginLeft"]);
    const thumbHeight = thumb.offsetHeight + parseFloat(thumbStyle["marginTop"]) + parseFloat(thumbStyle["marginBottom"]);
    this.thumbSize_ = [thumbWidth, thumbHeight];
    if (containerWidth > containerHeight) {
      this.direction_ = Direction.HORIZONTAL;
      this.widthLimit_ = containerWidth - thumbWidth;
    } else {
      this.direction_ = Direction.VERTICAL;
      this.heightLimit_ = containerHeight - thumbHeight;
    }
    return this.sliderInitialized_ = true;
  }
  handleContainerClick_(event) {
    const view = this.getMap().getView();
    const relativePosition = this.getRelativePosition_(
      event.offsetX - this.thumbSize_[0] / 2,
      event.offsetY - this.thumbSize_[1] / 2
    );
    const resolution = this.getResolutionForPosition_(relativePosition);
    const zoom = view.getConstrainedZoom(view.getZoomForResolution(resolution));
    view.animateInternal({
      zoom,
      duration: this.duration_,
      easing: easeOut
    });
  }
  handleDraggerStart_(event) {
    if (!this.dragging_ && event.target === this.element.firstElementChild) {
      const element = this.element.firstElementChild;
      this.getMap().getView().beginInteraction();
      this.startX_ = event.clientX - parseFloat(element.style.left);
      this.startY_ = event.clientY - parseFloat(element.style.top);
      this.dragging_ = true;
      if (this.dragListenerKeys_.length === 0) {
        const drag = this.handleDraggerDrag_;
        const end = this.handleDraggerEnd_;
        const doc = this.getMap().getOwnerDocument();
        this.dragListenerKeys_.push(
          listen(doc, EventType_default2.POINTERMOVE, drag, this),
          listen(doc, EventType_default2.POINTERUP, end, this)
        );
      }
    }
  }
  handleDraggerDrag_(event) {
    if (this.dragging_) {
      const deltaX = event.clientX - this.startX_;
      const deltaY = event.clientY - this.startY_;
      const relativePosition = this.getRelativePosition_(deltaX, deltaY);
      this.currentResolution_ = this.getResolutionForPosition_(relativePosition);
      this.getMap().getView().setResolution(this.currentResolution_);
    }
  }
  handleDraggerEnd_(event) {
    if (this.dragging_) {
      const view = this.getMap().getView();
      view.endInteraction();
      this.dragging_ = false;
      this.startX_ = void 0;
      this.startY_ = void 0;
      this.dragListenerKeys_.forEach(unlistenByKey);
      this.dragListenerKeys_.length = 0;
    }
  }
  setThumbPosition_(res) {
    const position = this.getPositionForResolution_(res);
    const thumb = this.element.firstElementChild;
    if (this.direction_ == Direction.HORIZONTAL) {
      thumb.style.left = this.widthLimit_ * position + "px";
    } else {
      thumb.style.top = this.heightLimit_ * position + "px";
    }
  }
  getRelativePosition_(x, y) {
    let amount;
    if (this.direction_ === Direction.HORIZONTAL) {
      amount = x / this.widthLimit_;
    } else {
      amount = y / this.heightLimit_;
    }
    return clamp(amount, 0, 1);
  }
  getResolutionForPosition_(position) {
    const fn = this.getMap().getView().getResolutionForValueFunction();
    return fn(1 - position);
  }
  getPositionForResolution_(res) {
    const fn = this.getMap().getView().getValueForResolutionFunction();
    return clamp(1 - fn(res), 0, 1);
  }
  render(mapEvent) {
    if (!mapEvent.frameState) {
      return;
    }
    if (!this.sliderInitialized_ && !this.initSlider_()) {
      return;
    }
    const res = mapEvent.frameState.viewState.resolution;
    this.currentResolution_ = res;
    this.setThumbPosition_(res);
  }
};
var ZoomSlider_default = ZoomSlider;

export {
  ZoomSlider_default
};
//# sourceMappingURL=chunk-7NKDTQDH.js.map
